# 程序设计文档

## 1. 项目概述

本项目是一个基于Cocos2d-x框架开发的卡牌消除类游戏。采用MVC架构模式。

### 1.1 技术架构

- **引擎框架**: Cocos2d-x
- **开发语言**: C++
- **架构模式**: MVC（Model-View-Controller）

### 1.2 目录结构

```
Classes/
├── models/          # 数据模型层
├── views/           # 视图层
├── controllers/     # 控制器层
├── managers/        # 管理器层
├── services/        # 服务层
└── configs/         # 配置层
```

## 2. 核心模块说明

### 2.1 数据模型（Models）

- **CardModel**: 单张卡牌的数据模型，存储卡牌类型、位置、状态等
- **GameModel**: 游戏状态数据，管理所有卡牌和游戏区域
- **UndoModel**: 撤销操作记录的数据模型

### 2.2 视图层（Views）

- **CardView**: 卡牌的视觉显示和交互
- **GameView**: 游戏界面的整体显示管理

### 2.3 控制器层（Controllers）

- **GameController**: 游戏主控制器，处理用户操作和业务逻辑

### 2.4 管理器层（Managers）

- **UndoManager**: 撤销功能管理器，处理撤销操作的执行

## 3. 扩展指南

### 3.1 如何新增一个卡牌类型

新增卡牌类型主要涉及三个步骤：

#### 步骤1: 定义卡牌类型枚举

在 `Classes/configs/models/CardTypes.h` 中的相应枚举中添加新类型：

**新增牌面类型（如添加"Joker"）**：
```cpp
enum CardFaceType
{
    // ... 现有类型 ...
    CFT_KING,
    CFT_JOKER,        // 新增：小丑牌
    CFT_NUM_CARD_FACE_TYPES
};
```

**新增花色类型（如添加"星"）**：
```cpp
enum CardSuitType
{
    // ... 现有类型 ...
    CST_SPADES,
    CST_STAR,         // 新增：星花色
    CST_NUM_CARD_SUIT_TYPES
};
```

#### 步骤2: 添加图片资源

按照现有命名规则在 `Resources/res/` 目录下添加图片文件：

- **数字图片**: `res/number/big_red_JOKER.png`, `res/number/small_red_JOKER.png` 等
- **花色图片**: `res/suits/star.png`

命名规则：
- 数字：`big_red_<牌面>.png` / `big_black_<牌面>.png`（大号）
- 数字：`small_red_<牌面>.png` / `small_black_<牌面>.png`（小号）
- 花色：`<花色名>.png`

#### 步骤3: 更新路径生成逻辑（如需要）

如果新增的类型需要特殊的路径映射规则，在 `Classes/views/CardView.cpp` 的以下函数中添加对应的case：

- `getCardNumberPath()`: 大号数字图片路径
- `getCardNumberPathSmall()`: 小号数字图片路径
- `getCardSuitPath()`: 花色图片路径

例如：
```cpp
std::string CardView::getCardNumberPath() const
{
    // ... 现有代码 ...
    switch (face)
    {
        // ... 现有case ...
        case CFT_KING: faceStr = "K"; break;
        case CFT_JOKER: faceStr = "JOKER"; break;  // 新增
        default: return "";
    }
    // ...
}
```

**注意事项**：
- 如果新类型使用标准命名规则（牌面名直接对应文件名），可能无需修改代码
- 确保 `CardModel::getCardValue()` 能正确处理新类型（用于匹配逻辑）
- 如果需要特殊的匹配规则，修改 `CardModel::canMatchWith()` 方法

### 3.2 如何新增一个回退功能类型

新增回退功能类型需要在四个地方进行修改：

#### 步骤1: 定义撤销操作类型

在 `Classes/models/UndoModel.h` 的 `UndoActionType` 枚举中添加新类型：

```cpp
enum UndoActionType
{
    UAT_NONE = 0,
    UAT_STACK_REPLACE,
    UAT_PLAYFIELD_MATCH,
    UAT_NEW_ACTION,        // 新增：新操作类型
};
```

#### 步骤2: 实现撤销逻辑

在 `Classes/managers/UndoManager.cpp` 的 `undo()` 方法中添加新类型的撤销逻辑：

```cpp
bool UndoManager::undo(UndoRecord& record)
{
    // ... 现有代码 ...
    
    // 根据操作类型执行不同的撤销逻辑
    if (record.actionType == UAT_STACK_REPLACE)
    {
        // ... 现有逻辑 ...
    }
    else if (record.actionType == UAT_PLAYFIELD_MATCH)
    {
        // ... 现有逻辑 ...
    }
    else if (record.actionType == UAT_NEW_ACTION)  // 新增
    {
        // 实现新操作的撤销逻辑
        // 1. 恢复数据模型状态（使用GameModel的接口）
        // 2. 恢复卡牌位置等数据
    }
    
    return true;
}
```

**撤销逻辑要点**：
- 使用 `_gameModel` 的接口恢复数据状态（如 `addPlayfieldCard()`, `removeTopBaseCard()` 等）
- 恢复 `record` 中保存的位置信息（`record.fromPosition`）
- 如有目标卡牌，使用 `record.targetCardId` 恢复

#### 步骤3: 添加记录撤销操作的函数

在 `Classes/controllers/GameController.h` 中声明记录函数：

```cpp
private:
    // ... 现有函数 ...
    void recordNewActionUndo(int cardId, int targetCardId);  // 新增
```

在 `Classes/controllers/GameController.cpp` 中实现：

```cpp
void GameController::recordNewActionUndo(int cardId, int targetCardId)
{
    if (!_gameModel)
    {
        return;
    }
    
    CardModel* card = _gameModel->getCardById(cardId);
    if (!card)
    {
        return;
    }
    
    UndoRecord record;
    record.actionType = UAT_NEW_ACTION;
    record.cardId = cardId;
    record.fromPosition = card->getPosition();
    record.toPosition = /* 目标位置 */;
    record.targetCardId = targetCardId;
    
    _gameModel->getUndoModel().addRecord(record);
}
```

**记录要点**：
- 在**执行操作之前**记录撤销信息
- 保存操作前的位置（`fromPosition`）和操作后的位置（`toPosition`）
- 如有替换操作，保存被替换的卡牌ID（`targetCardId`）

#### 步骤4: 添加视图更新逻辑

在 `Classes/controllers/GameController.cpp` 的 `updateViewsAfterUndo()` 方法中添加视图更新分支：

```cpp
void GameController::updateViewsAfterUndo(const UndoRecord& record)
{
    // ... 现有代码 ...
    
    if (record.actionType == UAT_PLAYFIELD_MATCH)
    {
        _undoPlayfieldMatch(record);
    }
    else if (record.actionType == UAT_STACK_REPLACE)
    {
        _undoStackReplace(record);
    }
    else if (record.actionType == UAT_NEW_ACTION)  // 新增
    {
        _undoNewAction(record);  // 新增辅助函数
    }
}
```

添加对应的辅助函数（建议函数长度不超过50行）：

```cpp
void GameController::_undoNewAction(const UndoRecord& record)
{
    // 1. 获取卡牌视图
    CardView* cardView = _gameView->getCardView(record.cardId);
    if (!cardView)
    {
        return;
    }
    
    // 2. 播放动画（如需要）
    // 3. 更新视图状态（调用GameView的接口，如addPlayfieldCard等）
    // 4. 重新绑定回调函数
}
```

**视图更新要点**：
- 使用 `_gameView->getCardView()` 获取卡牌视图
- 如需动画，使用 `cardView->playMoveAnimation()`
- 使用 `_gameView` 的接口更新卡牌显示位置（如 `addPlayfieldCard()`, `setBaseCard()` 等）
- 重新绑定回调函数以确保交互正常

#### 步骤5: 在执行操作时调用记录函数

在执行新操作的地方，在操作执行前调用记录函数：

```cpp
void GameController::executeNewAction(int cardId)
{
    // 1. 记录撤销操作（在执行操作之前）
    recordNewActionUndo(cardId, targetCardId);
    
    // 2. 执行实际操作
    // 更新GameModel
    // 更新视图
}
```

